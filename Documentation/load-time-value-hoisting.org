#+TITLE: The treatment of LOAD-TIME-VALUE forms in Cleavir

* Introduction
The LOAD-TIME-VALUE special form has been added to Common Lisp in 1989 as a
replacement of the dysfunctional sharpsign comma reader macro.  The history
and semantics of the form are described in the following sections of the
Hyperspec:
- [[http://www.lispworks.com/documentation/HyperSpec/Body/s_ld_tim.htm]]
- [[http://www.lispworks.com/documentation/HyperSpec/Body/03_bbb.htm]]
- http://www.lispworks.com/documentation/HyperSpec/Issues/iss216_w.htm

For the remaining discussion, we will always assume the LOAD-TIME-VALUE
form is processed by the file compiler.  The other modes of processing ---
EVAL and COMPILE --- are trivially handled by evaluating the form directly
in a null lexical environment and replacing its use with the resulting
value.

Several challenges arise for a compiler writer when dealing with
LOAD-TIME-VALUE forms:
1. The value of the LOAD-TIME-VALUE form may be a compile-time constant,
   either because because the first argument is a literal, or because the
   first argument evaluates to a constant in the sense of CONSTANTP.
2. Even if the LOAD-TIME-VALUE form is not a compile-time constant, its
   value can be treated like an immutable constant whenever the second
   argument is the symbol T.
3. Even if the first argument of a LOAD-TIME-VALUE form does not evaluate
   to a constant, the compiler may be able to derive some knowledge about
   the resulting value, e.g. type information.
4. A LOAD-TIME-VALUE form may appear in dead code.  If, additionally the
   form is free of side-effects, there is no need to store the form in the
   FASL at all.
5. Several LOAD-TIME-VALUE forms may be nested.  In this case, the standard
   mandates that each form is nevertheless only evaluated once.
6. Accidental modification of literal constants is a dangerous source of
   bugs.  A good compiler should attempt to detect and report such code and
   consequently needs to know about the intricacies of LOAD-TIME-VALUE
   forms.
7. Several constant LOAD-TIME-VALUE forms that evaluate to the same
   constant datum may be coalesced. Some heuristic must be used to detect
   such equivalent forms, e.g. if they are the same under EQUAL.

The following examples illustrate these issues:
#+BEGIN_SRC lisp
;; Obvious constants.
(load-time-value "abc")
(load-time-value #C(1 2))

;; A hidden constant.
(load-time-value (1+ 2))

;; A constant, but not a compile-time constant.
(load-time-value (string (gensym)) t)

;; A form with potentially valuable type information.
(load-time-value (make-array 5))

;; Dead code.
(when nil (load-time-value '(1 2 3)))

;; Nested LOAD-TIME-VALUE forms.
(defvar *i* 0)
(load-time-value
 (loop repeat 2 sum (load-time-value (incf *i*))))

;; Accidental modification of constant data. Users will appreciate compiler
;; warnings for such code.
(fill (load-time-value (list 5) t) 6)

;; Forms a compiler may want to coalesce.
'(1 2 3)
(load-time-value '(1 2 3))
(load-time-value (list 1 2 3) t)
#+END_SRC
* Current Practice
It is instructive to see how LOAD-TIME-VALUE forms are handled elsewhere in
the Common Lisp community.
** ANSI Test Suite
The ANSI test suite contains no dedicated tests for LOAD-TIME-VALUE forms.
It merely asserts that the corresponding symbol is bound to a special
operator in the Common Lisp package and that it receives either one or two
arguments.
** SBCL
The implementation of LOAD-TIME-VALUE resides in [[https://github.com/sbcl/sbcl/blob/master/src/compiler/ltv.lisp][src/compiler/ltv.lisp]],
with some related code in [[https://github.com/sbcl/sbcl/blob/master/src/compiler/dump.lisp][src/compiler/dump.lisp]] and in
[[https://github.com/sbcl/sbcl/blob/master/src/compiler/generic/genesis.lisp][src/compiler/generic/genesis.lisp]].
** CCL
** ECL
** ABCL
* A Proposed Solution
